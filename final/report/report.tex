\documentclass[a4paper,10pt]{article} % {{{
\usepackage{listings,amssymb,amsmath,amsthm,graphicx,float,hyperref,wrapfig, subfig}

\hypersetup{
    colorlinks=false,
    pdfborder={0 0 0},
}
\newcommand{\tsup}[1]{\ensuremath{\sp{\text{#1}}}}

\include{colors}

% gebruik '\and' tussen authors, '\\' voor extra info over een author.
\author{Harm Dermois (5027963) \and Joris Stork (6185320) \and
Lucas Swartsenburg (6174388) \and Sander van Veen (6167969)}

\title{Cobots and Sun SPOTs: a robotics project}

% }}}

\begin{document}

\maketitle

\abstract{}

\begin{figure}[H]
    \label{fig:cobot_sunspot_final}
    \centering
    \includegraphics[width=0.8\textwidth]{img/sunspot_cobot_final_together.png}
\end{figure}

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction} % {{{

This project concludes our team's involvement in a January 2011 robotics course
at the University of Amsterdam. The team consists of four second-year UvA
students enrolled for the BSc in computer science. The overall aim of this
project has been to address the challenges inherent in programming a
microcontroller based mobile robot and handling communication between multiple,
differing devices as might be required for a typical robotics application.

In this project, our team was given the task, firstly, of ``resuscitating'' the
UvA's Java-programmable ``Jobot'' robots, whose software development platform
had become defunct and inoperative. Our second task was to combine the Jobots'
mobility and sensing capabilities with the enhanced communications, sensing and
processing functionality of Sun SPOTs -- wireless sensor network devices
Developed by Sun Labs. In this way, we hoped to achieve a few things, namely to:

\begin{itemize}
    \item write, compile and load programs from scratch for a PIC based
    microcontroller board;
    \item create drivers for the servos and sensors connected to the board
    mentioned above;
    \item further explore the Sun SPOTs' sensing and communications
    characteristics through those devices' java frameworks;
    \item build a data communication channel between the Sun SPOTs and the
    standard microcontrollers on the Jobots. Investigate whether this could be
    achieved over an $I^2C$ bus;
    \item design an interface between our respective software implementations on
    the Jobot and on the Sun SPOTs;
    \item build a remote control system using the above interface;
    \item attempt some basic robot activities using our adapted, Sun SPOT
    controlled robot(s), such as: obstacle avoidance; reaching a goal;
    recognising a fellow robot; following a fellow robot, and so on; and
    \item learn to work with embedded chips and low-level signal handling.
\end{itemize}

Strict time and resource limitations took precedence over any adherence
to pre-formulated goals and methods. That said, our project was successful,
and our team achieved a bonus on the way.

This report describes the principal materials at our disposal and our approach
to completing the given project tasks. Our methods are described per challenge,
in chronological order of their occurrence, for each of the Sun SPOT; Cobot; and
Sun SPOT -- Cobot combination. This approach reflects the exploratory nature of
the project, in which a string of unexpected obstacles dictated the structure of
our efforts over the past two weeks.

% }}}

\pagebreak

\section{Methods} % {{{

\subsection{Materials} % {{{

This section provides an overview of the materials used in this project. More
detailed specifications of materials used in this project are listed in appendix
\ref{app:robot-hardware}, as relevant.

\subsubsection{Cobot}

\begin{figure}[h]
    \centering
    \subfloat[front]{\label{fig:cobotface}\includegraphics[width=0.4\textwidth]{img/cobot_face_sensor.png}}
    \subfloat[topview]{\label{fig:cobottop}\includegraphics[width=0.4\textwidth]{img/cobot_top_view.png}}
    \caption{The Cobot}
    \label{fig:cobotviews}
\end{figure}

The Cobot, the centrepiece of our project, is an adapted ``Jobot'',
re-christened to reflect the fact that our team reprogrammed the device in a
C-like language. The Jobot/Cobot is a battery powered, PIC microcontroller-based
mobile robot. It is about 10cm high and 25cm across. We disposed over three
Jobot/Cobot devices.

\subsubsection{Sun SPOTs}

\begin{figure}[H]
    \centering
    \subfloat[closed unit]{\label{fig:sunspot}\includegraphics[width=0.4\textwidth]{img/sunspot.png}}
    \subfloat[Cobot cabling attached]{\includegraphics[width=0.4\textwidth]{img/sunspot_cabled.png}}
    \caption{The Sun SPOT}
    \label{fig:sunspotviews}
\end{figure}

Then, the Sun SPOT: the device intended to enhance the Cobot's sensing and
communications capabilities. Sun SPOTs are relatively new, battery powered
wireless sensor network devices from the Sun Labs stable. Our team received one
set, comprising three Sun SPOTs.

\subsubsection{Other hardware}

\noindent In addition to these two key components, our project relied heavily on
several hardware tools and devices, as follows: We used a portable digital
oscilloscope to measure voltages on the various I/O pins on the SUN SPOTs and
microcontroller boards (as well testing the odd misbehaving battery). A USB
compatible Microchip programming device served to load compiled code onto the
Cobot, via a specially attached 8P8C type connector on Cobot's microcontroller
board. We sourced a USB to RS-232 adapter cable to make the serial connection to
the Cobot. For the various I/O connections we made use of standard soldering
equipment. Department staff helped build pins and wires adapted for the Sun
SPOTs' as well as the Cobots' I/O connectors, and provided two potential
dividers for the bit banging bus.

\subsubsection{Software}

A number of off-the-shelf software tools complemented a software toolchain
developed especially by our team for this project. The former notably included
Microchip's compiler for the Cobot microcontroller, and Sun's development toolkit
for the Sun SPOT platform. Our own toolchain included scripts written in Python,
and an assemblage of open source UNIX-like command line utilities to link up the
software development, compilation and upload stages in the programming cycle.

% }}}

\subsection{Establishing COM-to-USB connection} % {{{
\label{sub:Establishing COM-to-USB connection}

In order to see if a Cobot or Hemisson is performing some action, it is wise to
write debug information to a file or serial port. In this case, the serial port
was available on both robots, providing a ``real-time'' view of the
robot's successive actions.

Sander developed some python code to be able to command the Hemisson robot using
a python console connected in combination with a serial port. The following code
is an implementation of most of the features available in the Hemisson GUI.
This code has two advantages: it is platform independent (enabling Mac and Linux
PCs to send commands the Hemisson) and enables the user to automate certain
actions, such as creating a software loop that causes the Hemisson to drive
around a rectangle.

\input{src/hemisson}

\noindent We developed this utility to verify that communication over the
Hemisson's RS-232 COM port had been successful. When we started to develop code for the Cobot, the utility was initially useless, since the Cobot did not have a program in place to interpret the commands sent through the RS-232 COM port. The Cobot had to be programmed from scratch. Once we had written the necessary software handlers on the Cobot, though, our utility became useful once again.

% }}}

\subsection{Cobot} % {{{

% TODO: our initial approach

% TODO: write a general approach to solve the problems occurred during
% development of Cobot's code. -- what does this mean?

\subsubsection{Toolchain used to program the Cobot} % {{{
\label{ssub:Toolchain used to program the Cobot}

To program the Cobot we built a toolchain consisting of the following mixture of
pre-existing and custom-made software tools:

\begin{itemize}
    \item source code and compiled code for the Cobot, stored in a common
    working directory on UvA's science department servers;
    \item  the above directory mounted on a windows virtual machine and a Linux
    laptop over SSHFS\footnote{Secure SHell File System};
    \item Microchip's proprietary compiler for the Cobot's PIC microcontroller,
    running on the Windows virtual machine;
    \item our own python script, \texttt{compile.py}, running on the windows
    virtual machine: this automatically compiles the Cobot source code on the
    remote server when it changes;
    \item a python script on the Linux laptop to send commands to and read program
    output from the Cobot over the Cobot's RS-232 serial port;
\end{itemize}

\noindent First, we connected the shared directory using SSHFS:

\begin{verbatim}
$ sshfs USERNAME@deze.science.uva.nl:~/ ~/sremote -C -o cache=no
\end{verbatim}

The argument \texttt{-C} enables data compression during the transfer and
\texttt{-o cache=no} disables the file system cache (e.g. stat will respond with
the most recent data). With the file system cache left enabled, the overall
duration of the toolchain would have been larger due to the default four-second
file system cache. These four seconds were visible when the Mac machine running
the Windows VM waited for the source file to update, and again when the Linux
machine waited for the compiled hex file to update. Disabling the file system
cache reduced the overall toolchain process by four to eight seconds. Data
compression did not significantly reduce the overall process duration. We used
it because the transfers consisted largely of text files, which are especially
susceptible to compression.

Once we had the shared directory mounted on both the Linux and the Mac machine, we
were able to transfer data between those two.
\footnote{SSHFS is not easily employed from within Windows: this was our motivation for running Windows as a virtual machine on a Mac, which offers a more convenient implementation of SSHFS.} The
Windows virtual machine ran the compilation daemon (using \texttt{\$ python
compile.py}) and the Linux machine ran the programming daemon (using
\texttt{python upload.py}).\footnote{See appendix for the source code of these
daemons.} Both daemons use the respective modification times of the source and compiled hex files to trigger the necessary toolchain actions.

The programmer daemon uses the ``piklab'' package (in Debian-based
distributions: \texttt{sudo apt-get install piklab}) to write the hex file to
the Jobot. Be aware of the fact that piklab does not program the Jobot's
microcontroller right away, it is necessary to use the ICD2 Programmer, since
it is not possible to program the Jobot directly. The daemon will spawn a
sub process executing the Makefile's default target. The default target will
execute the following commands to program the Jobot:

\begin{verbatim}
$ sudo piklab-prog --port usb -p icd2 -d 18F450 -c connect
$ sudo piklab-prog --port usb -p icd2 -d 18F450 -c program file.hex
\end{verbatim}

It was necessary the execute these commands using \texttt{sudo}, because
piklab was not able to lock the USB-to-COM port otherwise. The second command
will also verify the programming process, thus verifying if the Jobot's
microcontroller contains the hex file we were uploading.

\begin{figure}[H]
\hspace{-1.2in}
\includegraphics[scale=0.5]{img/workspace}
\caption{Workspace used to develop the Cobot's source code. On the left is Vim
(an highly configurable text editor built to enable efficient text editing). On
the top right is a build log displayed (using the shell command: \texttt{\$
watch tail -n20 build.log}) and at the right bottom is a reader of the
connection to the serial port. It will simply display all the messages sent to
the RS-232 COM port. Those three windows are just terminals and Awesome
Window Manager is used to tile those windows together. Combined with the
toolchain, you have a full-featured IDE for development of the Cobot.}
\end{figure}

For the Sun SPOT we used the recommended software. Which is all
the software the Sun SPOT manager asks you to install when running it. This
might change as time progresses so I would recommend doing the same while
working with the SPOT. This gives you the most reliable software. The
SPOT manager handles all the environment variables needed to get
the program running.

% }}}

\subsubsection{Controlling the actuators} % {{{
\label{sub:Cobot implementation}

Since there was no manual or documentation available about the toolchain, nor
about the internals of the Jobot, the first week's progress of this assignment
was slow. Most of the time, we were trying to solve problems and looking for
more information about the microcontroller and servos on the internet.
Eventually, when all tools for the toolchain were obtained and successfully
working together, we were able to run example code on the Jobot. This was the
breakthrough we were waiting for: we were able to write our own code and program
the Jobot with our compiled source code.

When we were using the PCH version of the CCS C compiler, we found some example
source code in the directory of the CCS C compiler. We modified the example code
to proof the microcontroller can do something, and programmed this modified code
on the Jobot's microcontroller:

\input{src/ex_led}

\noindent Note: The code shown above is a heavily modified version of the
example file \texttt{ex\_led.c}, which is part of the CCS C compiler's examples.

% }}}

% }}}

\subsection{Sun SPOTs} % {{{
\label{sec:sunspot}

The Sun SPOT is a vital part of our project. We use the Sun SPOT to control the
robots. Initially, it was our plan to have communication between the robots
through these Sun SPOTs. Also, the information from the Robot's sensors were to
be sent to the Sun SPOTs to be interpreted and handled accordingly. For more
detailed information on the implementations see section \ref{sub:Sun SPOT
implementation}.

Both Sun SPOTs start up a \texttt{BootloaderListenerService}, so that we can
read the debug output at real-time on our computer. This was very useful to
debug the Java code. Both Sunspots extend the
\texttt{javax.microedition.midlet.MIDlet} class, so that all the functions the
Sun SPOT needs to operate are in the code.

\subsubsection{Communication between the Sun SPOTs} % {{{
\label{subsec:comm}

The first order of business was getting the Sun SPOTs to communicate with each
other. To do this you need to use the function on the Sun SPOT to start
listening for information. It is almost always required to filter some of these
packets, because if there are other Sun SPOTs communicating with each other.
You need to be sure you are receiving the right packets. We haven't implemented
this, because we were working in a secluded area away from other Sun SPOTs which
might interfere with out Sun SPOTs, but this is easily implemented in the code
we made. In the final code we do filter out packets without valid commands.
This will avoid most of the unwanted traffic, but we can still get some messages
that were not intended for us.

We send some information in the form of tilting the Sun SPOT. This was chosen
to figure out both how to send the information and to get to know how the
sensors (EDemoboard) of the Sun SPOT functioned. We wanted the communication
between to be both ways. So we had to use threads to get this working properly.
Without threads, the Sun SPOTs will often get stuck because of desynchronization.

With the implementation of these threads we finally managed to correctly send
the information between the two Sun SPOT. We built the foundations of the
communications between the two robots or as application as a remote control.
With this foundation it could be used to implement any sort of data transfer in
an orderly fashion and with the way we made the code it is very easy too expand
it for more difficult problems.

% }}}

% }}}

\subsection{Bringing the pieces together} % {{{
\label{subsec:Bringing the pieces together}

For this project we used one Sunspot to determine the movement of the robot (by
measuring the tilt) and sending that information using a wireless connection to
the other Sun SPOT. The other Sun SPOT will receive the datagram sent and uses
bit banging to send the received movement to the Cobot.

\subsubsection{Sun SPOT to Cobot: choosing a bus} % {{{
\label{ssub:bitbang}

First we thought we could send the data between the Sun SPOT and the Cobot via
the $I^2C$ bus, but halfway through the project, it was found out this wasn't
possible, because of a technical issues. Namely, the Sun SPOT can only handle a
voltage of 3V and the Cobot can only send signals of 5V. This is a big problem
if you want to communicate between the two without frying the Sun SPOT. Luckily
the Cobot can register voltages of 2V and higher so no modification had to be
made to get this to work.

This meant we had to use another method to get the information to the Cobot. The
solution that was given to us was the use of bit-banging. Bit-banging is a
technique for serial communications using software instead of dedicated
hardware. This means you got to send all the information bit by bit instead of
sending a full packet of bytes in the form on any given data type. If you want
to use this method it is needed to have good control of how and when the
information is sent. This means you are responsible for all the timings and
synchronizations between the parties. The good thing about bit-banging is that
it is low cost. It gives you more control and the best thing is that it can be
used in every languages and can be used on every system that can communicate
with software, because it is so low level.

In our case we started by first devising a deterministic bit banging protocol,
i.e. a protocol that does not make use of a clock signal. This involved
designing a hand shaking protocol to align the devices to the same starting
point on a transfer. We then simulated this between two Sun SPOTs.

\begin{figure}[H]
\label{fig:sunspotconnections}
\centering
\includegraphics{img/sunspotconnections1.png}
\caption{The Sun SPOT with connections added to the ground and the digital
I/O}
\end{figure}

% }}}

\subsubsection{Bit banging: hardware bus} % {{{

Now that we have both the Cobot ready to drive and have tested the bit-banging between the
Sun SPOTs. We can finally start putting the pieces together. Although we had all
the pieces, it was still hard to get them to work together properly.  The main
problem was touched on in the last part. The difference is voltage the two
pieces of hardware used. The Cobot uses a voltage of 5 and the Sun SPOT a
voltage of 3. This gives problems when you, want to send signals to from the
Cobot to the Sun SPOT.  \begin{equation} \label{eq:voltage} U = I*R
\end{equation}
So to solve this problem we had to make a wire with 2 serial resistances of 300
and 200 K $\Omega$. This makes sure only 3V gets to the Sun Spot and the
other 2V leaks out through the other side to the ground. Like you can see in
figure \ref{fig:handshaking}.
This solution is not valid if you are trying to send more complex information
than just a giving a high signal, because the message will get distorted if
there is a resistance between the sender and receiver.

\begin{figure}[H]
\label{fig:connection-schema}
\centering
\includegraphics[scale=0.5]{img/connection-schema.png}
\caption{Schema of the the Sun SPOT and Cobot connected using a resistance.}
\end{figure}

Also, we initially used timers for the Sun SPOTs to send datagrams to each
other. We could not use this timers from the Java code, since those timers did
not guarantee that a bit is transmitted: there is no guarantee the timers of
both devices are working correctly. We went for a deterministic approach by
implementing a state machine. The basic idea is really simple (you could only
transition from one state into another), but you have to make sure acknowledge
bits are continuously sent to both sides. In the figure displayed below is
shown how the transmission protocol for bit banging works, without using a
clock.

\begin{figure}[H]
\label{fig:handshaking}
\centering
\includegraphics[width=11cm]{img/handshaking.png}
\caption{The left image is a bit diagram of a normal transmission and right is a
simplified example of an error occurred during the transmission. To send one bit
from a device (blue labelled lines; sender) to another device (green labelled
lines; receiver), first put your data pin on the value you want to send. Then
you put your ACK flag on. Now, the receiver knows the sender is ready to send a
bit.  When the receiver sees the sender's ACK flag, the receiver read the value
of the data pin and puts his acknowledge flag on. When the receiver set its ACK
flag, the sender knows the message bit is received. The sender lowers its
acknowledge flag, and the receiver will followed by lowering its own ACK flag as
well. When both ACK flags are down, the process starts all over again. There is
also a reset flag, which indicates a restart of the whole process is required.
The receiver will set its reset flag, when an invalid value is received.}
\end{figure}

\begin{figure}[H]
\label{fig:cobot-sun-spot}
\centering
\includegraphics[scale=0.5]{img/cobot_and_sunspot.jpg}
\caption{Picture of the Sun SPOT and the Cobot connected to each other using our
custom-made bit banging connection.}
\end{figure}

% }}}

% }}}

% }}}

\pagebreak

\section{Implementation} % {{{
\label{sec:Implementation}

\subsection{Cobot implementation} % {{{
\label{sub:Cobot implementation}

Since there was no manual or documentation available about the toolchain (there
was no information available about what tools should be used), nor about the
internals of the Jobot, the first week's progress of this assignment was slow.
Most of the time, we were trying to solve problems and looking for more
information about the microcontroller and servos on the internet.  Eventually,
when all tools for the toolchain were obtained and successfully working
together, we were able to run example code on the Jobot. This was the
breakthrough we were waiting for: we were able to write our own code and program
the Jobot with our compiled source code.

\subsubsection{The first working example source code} % {{{
\label{ssub:The first working example source code}

When we were using the PCH version of the CCS C compiler, we found some example
source code in the directory of the CCS C compiler. We modified the example code
to proof the microcontroller can do something, and programmed this modified code
on the Jobot's microcontroller:

\input{src/ex_led}

\noindent Note: The code shown above is a heavily modified version of the
example file \texttt{ex\_led.c}, which is part of the CCS C compiler's examples.

% }}}

\subsubsection{Cobot's data receiver and error checker} % {{{
\label{ssub:Cobot's data receiver and error checker}

Transferring data between the Cobot and Sun SPOT is a bit fragile due to
external dependencies. For example, if a single bit is somehow not set to HIGH
when it should be, all the following and preceding bits of the message are
useless. To prevent these external dependencies from corrupting the messages, we
implemented a simple form of error checking: send the message twice and compare
the first message with the second. It was also possible to implement a more
robust error checking algorithm (e.g. Hamming code), but that would be overkill,
since we're just sending messages of three bits. There was no real benefit for
us to implementing a more complex algorithm, thus we kept our simple error
checker.

\input{src/data-receiver}

\noindent The expression \texttt{bit\_count-b-1} looks stupid, but is necessary,
because the CCS C compiler does not handle all branch conditions well. For
example, it does not handle these loops as expected:

\input{src/loops}

\noindent The first loop does print \text{i} with 0, 1 and 2. The second loop
prints a reversed output of the first loop, except it does not stop after 0. The
loop will continue and will print output until minus infinity is reached.
Therefore, we rewrote the loop of the receiver to the expression stated above.
As you can imagine, the lack of these simple operations make it really hard to
implement a driver for a robot.

% }}}

\subsubsection{Cobot's handshake and start} % {{{
\label{ssub:Cobot's handshake and start}

\input{src/cobot-start}

% }}}

% }}}

\subsection{Sun SPOT implementation} % {{{
\label{sub:Sun SPOT implementation}

For this project we used one Sunspot to determine the movement of the robot (by
measuring the tilt) and sending that information using a wireless connection to
the other Sun SPOT. The other Sun SPOT will receive the datagram sent and uses
bit banging to send the received movement to the Cobot. Both Sun SPOTs start up
a \texttt{BootloaderListenerService}, so that we can read the debug output at
real-time on our computer. This was very useful to debug the Java code. Both
Sunspots extend the \texttt{javax.microedition.midlet.MIDlet} class, so that all
the functions the Sun SPOT needs to operate are in the code.

% }}}

\subsubsection{Measure tilt and send wireless datagrams.} % {{{

Two threads are used to enable measuring tilt while sending datagrams. It is
necessary to create two threads, because sending/receiving datagrams is a
blocking operation. If a single thread is used for both tasks, the tilt is not
measured until the sending/receiving process is done.
\\
\\
\noindent Thread 1: \textbf{Measuring the tilt and determine what the next Cobot's
movement is or if the Cobot should halt.}
\\
\\
This thread continuously measures the tilt of the Sunspot. After measuring the
tilt, the next movement of the Cobot is determined by checking if the Y tilt is
larger than the X direction and by measuring if the tilt of either the Y or the
X direction is larger than 25 degrees. When this is not the case, the Sunspot
will set the movement to ``stop'' (thus no movement). If this is the case and X
is larger than Y, the Sunspot will set the direction to left or right. If the
tilt is negative, the Sun SPOT will turn right and vice versa.  Pretty much the
same case if the tilt in the Y direction is larger than the tilt in the X
direction. After the movement of the Cobot is determined, the LEDs are set in
such way that it is clear what is measured. The code of thread 1:

\input{src/measuring}

\noindent The constants ANGLE, RIGHT, LEFT, STOP, DRIVE and REVERSE are
specified in the main class. The constant ANGLE is set to \texttt{15} (= minimum
degrees used to filter unintended movements). The constants RIGHT, LEFT, STOP,
DRIVE and REVERSE are movement identifiers, since only bits are transferred
between the Sun SPOTs and the Sun SPOT and the Jobot, it is better to create
readable identifiers.
\\
\\
\noindent Thread 2: \textbf{Sending a wireless packet to the other Sunspot
containing the direction.}
\\
\\
This thread determines if the movement variable has been changed. If the
movement variable has changed, it will send a radiogram containing the
corresponding value of the movement to the other sunspot. Before this is
possible, a radio connection has to be established. The connection is made using
this function call: \texttt{Connector.open("radiogram://broadcast:37")}.

And a so called ``datagram'' has to be made. We write the integer that contains
the direction information to the datagram and this datagram is send to the other
Sunspot. The code of thread 2:

\input{src/sending}

\noindent The leds are set accordingly.
% }}}

\subsubsection{Receive movement and communicate with Cobot} % {{{

\noindent Thread 1: \textbf{Receive the datagrams sent by the Sun SPOT.}
\\
\\
After the direction has been sent, the Sun SPOT sets the LEDs in a way that
it is clear what the received direction is. It will also start up the bit
banging process.

% }}}

\subsubsection{Sun SPOT / Cobot handshake} % {{{
\label{ssub:Sun SPOT / Cobot handshake}

Before the second Sun SPOT starts receiving, it first needs to get a handshake
from the Cobot. The handshake is given when the Sunspot receives two high
signals on the digital pins that are used for input. If the Sunspot receives a
high signal on the reset input pin after the handshake, the Cobot didn't receive
the bits like they were send. When this happens, the same byte is send again
(twice for checking) to the Cobot. Every step of the bit banging process has to
get conformation from the Cobot that everything is OK. This is done by setting
the pins in a certain way. For more information about how the initial handshake
is done, we refer to the comments in the Sun SPOT and Cobot source code.

% }}}

% }}}

\section{Discussion} % {{{
% TODO: More decisions we made which we could have done better.

We did implement a way to send information between the two Sun SPOTs, but the
packets we have send are not safe, because we have not give them a signature.
We should have given the packet a ``magic number'' so we could recognize our
packets and ignore other traffic which might be going on. We have not tested
this thoroughly to see if this is might be a problem. Simply because there is no
need to secure the communication (no benefit for this project). Also, we kept
the commands we could give to the Cobot to a bare minimum of five. Forward,
left, right, stop and backwards. This can be upgraded to do some more complex
motions like a combination of forward and left, or a certain rotation angle.
This goes together with an upgrade of the Sun SPOT program to give such 
commands to the Cobot. 
Lastly, we use directly give a signal from the digital I/O ports to the 
Cobot, but it would be nice to use the high output ports to give these signals.
This gives you more security and allows for the Cobot to be less sensitive.

% }}}

\section{Results and conclusion} % {{{
%TODO: more things to add

Although our initial goals were not met. We managed to accomplish a lot with
respect to getting the Cobot to work. When we first got the assignment, we
thought most of the hardware and software were in order. After we found out this
was not the case our goal changed to getting the Cobot to work with our own
program. This goal was ultimately met. Our goals for the Sun SPOT was to send
information between the Sun SPOTs and between the Sun SPOT and Cobot. We almost
succeeded in doing this, but since we lacked time and we were missing one wire
to send information back to the Sun SPOT. We did not read the IR values of the
Cobot and we have not send any information to the Sun SPOT except for
confirmations (using the ACK flags).

While we were working on the project, there were a lot of hurdles to overcome
which were not necessarily part of the project. Some of the materials were
lacking or not available at the time like there were not enough working/charged
batteries. There was no information about the software to use for the project.
Also, the robots mainly use a COM port to do the programming which is mostly not
available any more on the newer computers and laptops. But I think the efforts
we made this year will make it proceed more smoothly in the coming years. This
project taught us more than just how to work with program robots but also the
hardships you have to deal with if were to start your own project. In the end we
were thinking out of the box and the hard work did pay off. Because we succeeded
in execute our code on the Jobot.

With all the code we have right now the most logical step would be to use Cobots
and let them communicate. One Cobot would be the master and the other one the
slave. We would give the master a route to walk and we would want the slave to
follow the master. After this we could use the sensors on the Cobot to avoid
collision and let it autonomously wander. While still sending information to the
slave to follow it. The list goes on and on. There were so many other things we
wanted to do, but cause of lack of time we could not. \\

\noindent \textbf{Conclusion}: We have not met our initial goals, but we did
manage to meet all our revised goals. Which was to get the Cobot to run a
program we wrote ourselves and to get it to communicate with the Sun SPOT.

% }}}

\section{Acknowledgements} % {{{

% TODO: teaching staff (names) for technical building potential divider, adapted
% pins and wires, and for attaching the Cobot's prorgramming port connector.
% James Caska and Peter van Lith for providing tips, manuals and diagrams for
% programming the Jobot without the Muvium Java layer.

% }}}

\pagebreak

\appendix

\section{Robot hardware specification} % {{{
\label{app:robot-hardware}

This section describes the hardware characteristics of key tools and devices
used in this project.

\subsection{Sun SPOT} % {{{
\label{app:Sun SPOT}

The Sun SPOT Device is a small, wireless, battery powered experimental platform.
It is programmed almost entirely in Java (hence the name ``Sun'', main developer
of the Java platform, in ``Sun SPOT'') to allow regular programmers to create
projects that used to require specialized embedded system development skills.
The hardware platform includes a range of built-in sensors as well as the
ability to easily interface to external devices.

Each Sun SPOT has a 180MHz 32-bit ARM920T core processor with 512Kb RAM and 4Mb
Flash. The sensor board contains:

\begin{itemize}
    \item One 3-axis accelerometer (with two range settings: 2G or 6G).
    \item One temperature sensor.
    \item One light sensor.
    \item Eight tri-color LEDs.
    \item Six analog inputs readable by an ADC.
    \item Two momentary switches.
    \item Five general purpose I/O pins.
    \item Four high current output pins.
    \item $2.4 GHz$ IEEE $802.15.4$ radio with integrated antenna;
    \item $AT91$ timer chip;
    \item USB interface;
    \item $2G/6G$ three-axis accelerometer;
    \item One temperature sensor;
    \item One light sensor;
    \item $3.7V$ rechargeable $750 mAh$ lithium-ion battery;
\end{itemize}

We also have a radio sensor board. The Sun SPOTs use a fully capable Java ME
implementation, called Squawk, that supports CLDC 1.1 and MIDP 1.0, plus
provides basic OS functionality. The VM executes directly out of flash memory.
All the device drivers are also written in Java, only a minimal part of the
virtual machine is written in C.

% }}}

\subsection{Jobot/Cobot} % {{{
\label{app:cobot}

\begin{itemize}
    \item PIC16F452 microcontroller with max $40MHz$ CPU clock, 256 byte
    EEPROM data, $32KB$ program memory
    \item Digital communication peripherals (1-A/E/USART, 1-MSSP(SPI/I2C))
    \item Three servos
    \item Three IR sensors
\end{itemize}

% }}}

\subsection{Hemisson} % {{{
\label{sub:Hemisson}

The Hemisson is a two-wheeled robot designed for mobility, that includes:
\begin{itemize}
    \item a PIC16F877 microcontroller with $20MHz$ CPU clock, 8bit,
    $8K$ $\times$ 14 bit words program memory, 368 bytes data memory, 256 bytes
    EEPROM data memory, 14 interrupts, I/O ports A,B,C,D,E, three timers,
    serial communications (MSSP, USART), parallel communications (PSP), 8
    input channel, 10 bit analog to digital module;
    \item two DC motors for independent control of two wheel. Open loop
    control without encoders;
    \item eight IR ambient light sensors;
    \item six IR obstacle detection sensors;
    \item two line detection sensors;
    \item a standard $9V$ (PP3) battery connector;
    \item serial port with DB9 connector;
    \item a TV remote receiver;
    \item a buzzer;
    \item four LEDs;
    \item four programmable switches;
    \item an extension bus for extra modules;
\end{itemize}

% }}}

\subsection{Tools} % {{{

% TODO: the following tools should include make, and key characteristics.

\subsubsection{Hardware} % {{{

% }}}

\subsubsection{Software} % {{{
\begin{itemize}
    \item Netbeans IDE with Sun SPOT modules(Latest version);
    \item Apache Ant(Latest version);
    \item Sun SPOT manager;
\end{itemize}
% }}}

% }}}

% }}}

\bibliographystyle{plain}
\bibliography{cited}

\end{document}
% vim: foldmethod=marker:
